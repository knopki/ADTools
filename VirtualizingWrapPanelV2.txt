Imports System.ComponentModel
Imports System.Windows.Controls.Primitives


' class from: https://github.com/samueldjack/VirtualCollection/blob/master/VirtualCollection/VirtualCollection/VirtualizingWrapPanel.cs
' MakeVisible() method from: http://www.switchonthecode.com/tutorials/wpf-tutorial-implementing-iscrollinfo

Public Class VirtualizingWrapPanel
    Inherits VirtualizingPanel
    Implements IScrollInfo
    Private Const ScrollLineAmount As Double = 16.0

    Private _extentSize As Size
    Private _viewportSize As Size
    Private _offset As Point
    Private _itemsControl As ItemsControl
    Private ReadOnly _childLayouts As New Dictionary(Of UIElement, Rect)()

    Public Shared ReadOnly ItemWidthProperty As DependencyProperty = DependencyProperty.Register("ItemWidth", GetType(Double), GetType(VirtualizingWrapPanel), New PropertyMetadata(1.0, AddressOf HandleItemDimensionChanged))

    Public Shared ReadOnly ItemHeightProperty As DependencyProperty = DependencyProperty.Register("ItemHeight", GetType(Double), GetType(VirtualizingWrapPanel), New PropertyMetadata(1.0, AddressOf HandleItemDimensionChanged))

    Private Shared ReadOnly VirtualItemIndexProperty As DependencyProperty = DependencyProperty.RegisterAttached("VirtualItemIndex", GetType(Integer), GetType(VirtualizingWrapPanel), New PropertyMetadata(-1))
    Private _itemsGenerator As IRecyclingItemContainerGenerator

    Private _isInMeasure As Boolean

    Private Shared Function GetVirtualItemIndex(obj As DependencyObject) As Integer
        Return CInt(obj.GetValue(VirtualItemIndexProperty))
    End Function

    Private Shared Sub SetVirtualItemIndex(obj As DependencyObject, value As Integer)
        obj.SetValue(VirtualItemIndexProperty, value)
    End Sub

    Public Property ItemHeight() As Double
        Get
            Return CDbl(GetValue(ItemHeightProperty))
        End Get
        Set
            SetValue(ItemHeightProperty, Value)
        End Set
    End Property

    Public Property ItemWidth() As Double
        Get
            Return CDbl(GetValue(ItemWidthProperty))
        End Get
        Set
            SetValue(ItemWidthProperty, Value)
        End Set
    End Property

    Public Sub New()
        If Not DesignerProperties.GetIsInDesignMode(Me) Then
            Dispatcher.BeginInvoke(DirectCast(AddressOf Initialize, Action))
        End If
    End Sub

    Private Sub Initialize()
        _itemsControl = ItemsControl.GetItemsOwner(Me)
        _itemsGenerator = DirectCast(ItemContainerGenerator, IRecyclingItemContainerGenerator)

        InvalidateMeasure()
    End Sub

    Protected Overrides Sub OnItemsChanged(sender As Object, args As ItemsChangedEventArgs)
        MyBase.OnItemsChanged(sender, args)

        InvalidateMeasure()
    End Sub

    Protected Overrides Function MeasureOverride(availableSize As Size) As Size
        If _itemsControl Is Nothing Then
            Return availableSize
        End If

        _isInMeasure = True
        _childLayouts.Clear()

        Dim extentInfo = GetExtentInfo(availableSize, ItemHeight)

        EnsureScrollOffsetIsWithinConstrains(extentInfo)

        Dim layoutInfo = GetLayoutInfo(availableSize, ItemHeight, extentInfo)

        RecycleItems(layoutInfo)

        ' Determine where the first item is in relation to previously realized items
        Dim generatorStartPosition = _itemsGenerator.GeneratorPositionFromIndex(layoutInfo.FirstRealizedItemIndex)

        Dim visualIndex = 0

        Dim currentX = layoutInfo.FirstRealizedItemLeft
        Dim currentY = layoutInfo.FirstRealizedLineTop

        Using _itemsGenerator.StartAt(generatorStartPosition, GeneratorDirection.Forward, True)
            Dim itemIndex = layoutInfo.FirstRealizedItemIndex
            While itemIndex <= layoutInfo.LastRealizedItemIndex
                Dim newlyRealized As Boolean

                Dim child = DirectCast(_itemsGenerator.GenerateNext(newlyRealized), UIElement)
                SetVirtualItemIndex(child, itemIndex)

                If newlyRealized Then
                    InsertInternalChild(visualIndex, child)
                Else
                    ' check if item needs to be moved into a new position in the Children collection
                    If visualIndex < Children.Count Then
                        If Children(visualIndex) IsNot child Then
                            Dim childCurrentIndex = Children.IndexOf(child)

                            If childCurrentIndex >= 0 Then
                                RemoveInternalChildRange(childCurrentIndex, 1)
                            End If

                            InsertInternalChild(visualIndex, child)
                        End If
                    Else
                        ' we know that the child can't already be in the children collection
                        ' because we've been inserting children in correct visualIndex order,
                        ' and this child has a visualIndex greater than the Children.Count
                        AddInternalChild(child)
                    End If
                End If

                ' only prepare the item once it has been added to the visual tree
                _itemsGenerator.PrepareItemContainer(child)

                child.Measure(New Size(ItemWidth, ItemHeight))

                _childLayouts.Add(child, New Rect(currentX, currentY, ItemWidth, ItemHeight))

                If currentX + ItemWidth * 2 >= availableSize.Width Then
                    ' wrap to a new line
                    currentY += ItemHeight
                    currentX = 0
                Else
                    currentX += ItemWidth
                End If
                itemIndex += 1
                visualIndex += 1
            End While
        End Using

        RemoveRedundantChildren()
        UpdateScrollInfo(availableSize, extentInfo)

        Dim desiredSize = New Size(If(Double.IsInfinity(availableSize.Width), 0, availableSize.Width), If(Double.IsInfinity(availableSize.Height), 0, availableSize.Height))

        _isInMeasure = False

        Return desiredSize
    End Function

    Private Sub EnsureScrollOffsetIsWithinConstrains(extentInfo As ExtentInfo)
        _offset.Y = Clamp(_offset.Y, 0, extentInfo.MaxVerticalOffset)
    End Sub

    Private Sub RecycleItems(layoutInfo As ItemLayoutInfo)
        For Each child As UIElement In Children
            Dim virtualItemIndex = GetVirtualItemIndex(child)

            If virtualItemIndex < layoutInfo.FirstRealizedItemIndex OrElse virtualItemIndex > layoutInfo.LastRealizedItemIndex Then
                Dim generatorPosition = _itemsGenerator.GeneratorPositionFromIndex(virtualItemIndex)
                If generatorPosition.Index >= 0 Then
                    _itemsGenerator.Recycle(generatorPosition, 1)
                End If
            End If

            SetVirtualItemIndex(child, -1)
        Next
    End Sub

    Protected Overrides Function ArrangeOverride(finalSize As Size) As Size
        For Each child As UIElement In Children
            child.Arrange(_childLayouts(child))
        Next

        Return finalSize
    End Function

    Private Sub UpdateScrollInfo(availableSize As Size, extentInfo As ExtentInfo)
        _viewportSize = availableSize
        _extentSize = New Size(availableSize.Width, extentInfo.ExtentHeight)

        InvalidateScrollInfo()
    End Sub

    Private Sub RemoveRedundantChildren()
        ' iterate backwards through the child collection because we're going to be
        ' removing items from it
        For i = Children.Count - 1 To 0 Step -1
            Dim child = Children(i)

            ' if the virtual item index is -1, this indicates
            ' it is a recycled item that hasn't been reused this time round
            If GetVirtualItemIndex(child) = -1 Then
                RemoveInternalChildRange(i, 1)
            End If
        Next
    End Sub

    Private Function GetLayoutInfo(availableSize As Size, itemHeight__1 As Double, extentInfo As ExtentInfo) As ItemLayoutInfo
        If _itemsControl Is Nothing Then
            Return New ItemLayoutInfo()
        End If

        ' we need to ensure that there is one realized item prior to the first visible item, and one after the last visible item,
        ' so that keyboard navigation works properly. For example, when focus is on the first visible item, and the user
        ' navigates up, the ListBox selects the previous item, and the scrolls that into view - and this triggers the loading of the rest of the items 
        ' in that row

        Dim firstVisibleLine = CInt(Math.Floor(VerticalOffset / itemHeight__1))

        Dim firstRealizedIndex = Math.Max(extentInfo.ItemsPerLine * firstVisibleLine - 1, 0)
        Dim firstRealizedItemLeft = (firstRealizedIndex Mod extentInfo.ItemsPerLine) * ItemWidth - HorizontalOffset
        Dim firstRealizedItemTop = (firstRealizedIndex / extentInfo.ItemsPerLine) * itemHeight__1 - VerticalOffset

        Dim firstCompleteLineTop = (If(firstVisibleLine = 0, firstRealizedItemTop, firstRealizedItemTop + ItemHeight))
        Dim completeRealizedLines = CInt(Math.Ceiling((availableSize.Height - firstCompleteLineTop) / itemHeight__1))

        Dim lastRealizedIndex = Math.Min(firstRealizedIndex + completeRealizedLines * extentInfo.ItemsPerLine + 2, _itemsControl.Items.Count - 1)

        Return New ItemLayoutInfo() With {
                    .FirstRealizedItemIndex = firstRealizedIndex,
                    .FirstRealizedItemLeft = firstRealizedItemLeft,
                    .FirstRealizedLineTop = firstRealizedItemTop,
                    .LastRealizedItemIndex = lastRealizedIndex
                }
    End Function

    Private Function GetExtentInfo(viewPortSize As Size, itemHeight__1 As Double) As ExtentInfo
        If _itemsControl Is Nothing Then
            Return New ExtentInfo()
        End If

        Dim itemsPerLine = Math.Max(CInt(Math.Floor(viewPortSize.Width / ItemWidth)), 1)
        Dim totalLines = CInt(Math.Ceiling(CDbl(_itemsControl.Items.Count) / itemsPerLine))
        Dim extentHeight = Math.Max(totalLines * ItemHeight, viewPortSize.Height)

        Return New ExtentInfo() With {
                    .ItemsPerLine = itemsPerLine,
                    .TotalLines = totalLines,
                    .ExtentHeight = extentHeight,
                    .MaxVerticalOffset = extentHeight - viewPortSize.Height
                }
    End Function

    Public Sub LineUp() Implements IScrollInfo.LineUp
        SetVerticalOffset(VerticalOffset - ScrollLineAmount)
    End Sub

    Public Sub LineDown() Implements IScrollInfo.LineDown
        SetVerticalOffset(VerticalOffset + ScrollLineAmount)
    End Sub

    Public Sub LineLeft() Implements IScrollInfo.LineLeft
        SetHorizontalOffset(HorizontalOffset + ScrollLineAmount)
    End Sub

    Public Sub LineRight() Implements IScrollInfo.LineRight
        SetHorizontalOffset(HorizontalOffset - ScrollLineAmount)
    End Sub

    Public Sub PageUp() Implements IScrollInfo.PageUp
        SetVerticalOffset(VerticalOffset - ViewportHeight)
    End Sub

    Public Sub PageDown() Implements IScrollInfo.PageDown
        SetVerticalOffset(VerticalOffset + ViewportHeight)
    End Sub

    Public Sub PageLeft() Implements IScrollInfo.PageLeft
        SetHorizontalOffset(HorizontalOffset + ItemWidth)
    End Sub

    Public Sub PageRight() Implements IScrollInfo.PageRight
        SetHorizontalOffset(HorizontalOffset - ItemWidth)
    End Sub

    Public Sub MouseWheelUp() Implements IScrollInfo.MouseWheelUp
        SetVerticalOffset(VerticalOffset - ScrollLineAmount * SystemParameters.WheelScrollLines)
    End Sub

    Public Sub MouseWheelDown() Implements IScrollInfo.MouseWheelDown
        SetVerticalOffset(VerticalOffset + ScrollLineAmount * SystemParameters.WheelScrollLines)
    End Sub

    Public Sub MouseWheelLeft() Implements IScrollInfo.MouseWheelLeft
        SetHorizontalOffset(HorizontalOffset - ScrollLineAmount * SystemParameters.WheelScrollLines)
    End Sub

    Public Sub MouseWheelRight() Implements IScrollInfo.MouseWheelRight
        SetHorizontalOffset(HorizontalOffset + ScrollLineAmount * SystemParameters.WheelScrollLines)
    End Sub

    Public Sub SetHorizontalOffset(offset As Double) Implements IScrollInfo.SetHorizontalOffset
        If _isInMeasure Then
            Return
        End If

        offset = Clamp(offset, 0, ExtentWidth - ViewportWidth)
        _offset = New Point(offset, _offset.Y)

        InvalidateScrollInfo()
        InvalidateMeasure()
    End Sub

    Public Sub SetVerticalOffset(offset As Double) Implements IScrollInfo.SetVerticalOffset
        If _isInMeasure Then
            Return
        End If

        offset = Clamp(offset, 0, ExtentHeight - ViewportHeight)
        _offset = New Point(_offset.X, offset)

        InvalidateScrollInfo()
        InvalidateMeasure()
    End Sub

    Public Function MakeVisible(visual As Visual, rectangle As Rect) As Rect Implements IScrollInfo.MakeVisible
        If rectangle.IsEmpty OrElse visual Is Nothing OrElse visual Is Me OrElse Not IsAncestorOf(visual) Then
            Return Rect.Empty
        End If

        rectangle = visual.TransformToAncestor(Me).TransformBounds(rectangle)

        Dim viewRect = New Rect(HorizontalOffset, VerticalOffset, ViewportWidth, ViewportHeight)
        rectangle.X += viewRect.X
        rectangle.Y += viewRect.Y

        viewRect.X = CalculateNewScrollOffset(viewRect.Left, viewRect.Right, rectangle.Left, rectangle.Right)
        viewRect.Y = CalculateNewScrollOffset(viewRect.Top, viewRect.Bottom, rectangle.Top, rectangle.Bottom)

        SetHorizontalOffset(viewRect.X)
        SetVerticalOffset(viewRect.Y)
        rectangle.Intersect(viewRect)

        rectangle.X -= viewRect.X
        rectangle.Y -= viewRect.Y

        Return rectangle
    End Function

    Private Shared Function CalculateNewScrollOffset(topView As Double, bottomView As Double, topChild As Double, bottomChild As Double) As Double
        Dim offBottom = topChild < topView AndAlso bottomChild < bottomView
        Dim offTop = bottomChild > bottomView AndAlso topChild > topView
        Dim tooLarge = (bottomChild - topChild) > (bottomView - topView)

        If Not offBottom AndAlso Not offTop Then
            Return topView
        End If

        If (offBottom AndAlso Not tooLarge) OrElse (offTop AndAlso tooLarge) Then
            Return topChild
        End If

        Return bottomChild - (bottomView - topView)
    End Function


    Public Function GetVisibleItemsRange() As ItemLayoutInfo
        Return GetLayoutInfo(_viewportSize, ItemHeight, GetExtentInfo(_viewportSize, ItemHeight))
    End Function

    Public Property CanVerticallyScroll() As Boolean Implements IScrollInfo.CanVerticallyScroll
        Get
            Return m_CanVerticallyScroll
        End Get
        Set
            m_CanVerticallyScroll = Value
        End Set
    End Property
    Private m_CanVerticallyScroll As Boolean

    Public Property CanHorizontallyScroll() As Boolean Implements IScrollInfo.CanHorizontallyScroll
        Get
            Return m_CanHorizontallyScroll
        End Get
        Set
            m_CanHorizontallyScroll = Value
        End Set
    End Property
    Private m_CanHorizontallyScroll As Boolean

    Public ReadOnly Property ExtentWidth() As Double Implements IScrollInfo.ExtentWidth
        Get
            Return _extentSize.Width
        End Get
    End Property

    Public ReadOnly Property ExtentHeight() As Double Implements IScrollInfo.ExtentHeight
        Get
            Return _extentSize.Height
        End Get
    End Property

    Public ReadOnly Property ViewportWidth() As Double Implements IScrollInfo.ViewportWidth
        Get
            Return _viewportSize.Width
        End Get
    End Property

    Public ReadOnly Property ViewportHeight() As Double Implements IScrollInfo.ViewportHeight
        Get
            Return _viewportSize.Height
        End Get
    End Property

    Public ReadOnly Property HorizontalOffset() As Double Implements IScrollInfo.HorizontalOffset
        Get
            Return _offset.X
        End Get
    End Property

    Public ReadOnly Property VerticalOffset() As Double Implements IScrollInfo.VerticalOffset
        Get
            Return _offset.Y
        End Get
    End Property

    Public Property ScrollOwner() As ScrollViewer Implements IScrollInfo.ScrollOwner
        Get
            Return m_ScrollOwner
        End Get
        Set
            m_ScrollOwner = Value
        End Set
    End Property
    Private m_ScrollOwner As ScrollViewer

    Private Sub InvalidateScrollInfo()
        If ScrollOwner IsNot Nothing Then
            ScrollOwner.InvalidateScrollInfo()
        End If
    End Sub

    Private Shared Sub HandleItemDimensionChanged(d As DependencyObject, e As DependencyPropertyChangedEventArgs)
        Dim wrapPanel = TryCast(d, VirtualizingWrapPanel)

        If wrapPanel IsNot Nothing Then
            wrapPanel.InvalidateMeasure()
        End If
    End Sub

    Private Function Clamp(value As Double, min As Double, max As Double) As Double
        Return Math.Min(Math.Max(value, min), max)
    End Function

    Friend Class ExtentInfo
        Public ItemsPerLine As Integer
        Public TotalLines As Integer
        Public ExtentHeight As Double
        Public MaxVerticalOffset As Double
    End Class

    Public Class ItemLayoutInfo
        Public FirstRealizedItemIndex As Integer
        Public FirstRealizedLineTop As Double
        Public FirstRealizedItemLeft As Double
        Public LastRealizedItemIndex As Integer
    End Class
End Class

